# Fleet Commander: Multi-Project Meta-Agent Specification

**Version:** 2.0
**Status:** Draft
**Updated:** 2026-01-11

## Overview

Build a centralized "Fleet Commander" agent that monitors and coordinates multiple Claude Code agents working across different projects. The commander provides a single point of contact for users to understand what's happening across their entire codebase ecosystem.

### Control-Plane / Data-Plane Split

- **Workers (per repo/terminal)** = Data Plane: Do work, write status, optionally update project skills
- **Fleet Commander (in Mimesis)** = Control Plane: Watches worker outputs, becomes single point of contact

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     FLEET COMMANDER (Always-On Daemon)                       â”‚
â”‚  Location: ~/mimesis/ (or dedicated terminal)                                â”‚
â”‚  Skills: One per monitored project (auto-generated by workers)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    STATUS FILE WATCHER                               â”‚   â”‚
â”‚  â”‚  Watches: ~/.claude/projects/**/.claude/status.*.md                  â”‚   â”‚
â”‚  â”‚  Debounce: 250-500ms per file                                        â”‚   â”‚
â”‚  â”‚  Parse: YAML front matter (gray-matter)                              â”‚   â”‚
â”‚  â”‚  Dedupe: (project_id, updated, status, task_id)                      â”‚   â”‚
â”‚  â”‚  Output: Append to notifications.jsonl                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â”‚                                               â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚            â–¼                 â–¼                 â–¼                            â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚    â”‚  Project A   â”‚  â”‚  Project B   â”‚  â”‚  Project C   â”‚                    â”‚
â”‚    â”‚  Worker      â”‚  â”‚  Worker      â”‚  â”‚  Worker      â”‚                    â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                    â”‚
â”‚    â”‚ status.md    â”‚  â”‚ status.md    â”‚  â”‚ status.md    â”‚                    â”‚
â”‚    â”‚ project_id   â”‚  â”‚ project_id   â”‚  â”‚ project_id   â”‚                    â”‚
â”‚    â”‚ base_commit  â”‚  â”‚ base_commit  â”‚  â”‚ base_commit  â”‚                    â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                                                                              â”‚
â”‚  Commander Skills (in ~/.claude/skills/projects/):                          â”‚
â”‚    <project_id>/SKILL.md  - Business + tech context per project             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## The Contract: Three Artifacts

Different artifacts with different lifecycles provide reliability and separation of concerns.

### A) Status Snapshot (Mutable, "Latest State")

Written by worker hooks. Overwritten frequently. Used for "current state".

**Location:** `<project>/.claude/status.<sessionId>.md`

### B) Event Log (Append-Only, "What Happened")

Produced by watcher/daemon based on status changes. Used for "recent activity" and "history".

**Location:** `~/.claude/commander/notifications.jsonl`

### C) Project Skill (Semi-Stable, "Knowledge")

Updated only after **big** tasks (or explicitly requested). Used for "what is this repo?", "how does it work?".

**Location:** `~/.claude/skills/projects/<project_id>/SKILL.md`

---

## Status Schema v2

Keep the Markdown body human-friendly, but treat YAML front matter as the machine API.

```markdown
---
schema: status.v2
project_id: mimesis__a1b2c3d4
repo_name: mimesis
repo_root: /Users/olivier/Desktop/motium_github/mimesis
git_remote: git@github.com:motium/mimesis.git

status: working            # idle|working|blocked|completed|failed
updated: 2026-01-11T09:00:00Z

task_id: 2026-01-11T0900Z__auth__01
task: Implementing user authentication
task_size_intent: big      # agent-declared (optional)
task_size_actual: small    # hook-computed at stop (optional until stop)
importance: normal         # low|normal|high (optional, future: routing)

base_commit: 1a2b3c4
head_commit: 5d6e7f8
branch: feature/auth
dirty: true

blockers:
  - Waiting on OAuth client ID from ops

next_steps:
  - Add login route tests
  - Update docs/auth.md

docs_touched:
  - docs/auth.md
files_touched:
  - src/auth/*
---
# Status: working

## Progress
- Implemented middleware skeleton
- Added env var config

## Notes
- Using JWT with rotating keys
```

### Project ID Generation

Stable identifier (not path decoding). Recommended: hash of git remote + repo name.

```python
def generate_project_id(repo_root: str) -> str:
    """Generate stable project_id from git info."""
    try:
        remote = subprocess.check_output(
            ["git", "remote", "get-url", "origin"],
            cwd=repo_root, text=True
        ).strip()
        repo_name = Path(repo_root).name
        hash_input = f"{remote}:{repo_name}"
        short_hash = hashlib.sha256(hash_input.encode()).hexdigest()[:8]
        return f"{repo_name}__{short_hash}"
    except:
        # Fallback to path hash
        short_hash = hashlib.sha256(repo_root.encode()).hexdigest()[:8]
        return f"{Path(repo_root).name}__{short_hash}"
```

---

## Task Sizing: Computed at Stop

The agent expresses intent (`task_size_intent`), but the stop hook **computes** actual size (`task_size_actual`) using diffs. This is safer and cheaper than trusting agent declaration.

### Heuristic (Simple + Effective)

Compute from `base_commit` â†’ current working tree:

| Condition | Result |
|-----------|--------|
| `changed_files >= 4` | big |
| `added + removed >= 200` lines | big |
| `new_files >= 1` | big |
| `duration_minutes >= 20` | big |
| Otherwise | small |

### Override

If front matter includes `force_skill_update: true`, treat as big.

### Implementation (Stop Hook)

```python
def compute_task_size(repo_root: str, base_commit: str, start_time: str) -> str:
    """Compute task size from git diff and duration."""
    try:
        # Get diff stats
        result = subprocess.run(
            ["git", "diff", "--numstat", base_commit],
            cwd=repo_root, capture_output=True, text=True, timeout=5
        )

        lines = result.stdout.strip().split('\n') if result.stdout.strip() else []
        total_added = 0
        total_removed = 0
        changed_files = len(lines)

        for line in lines:
            parts = line.split('\t')
            if len(parts) >= 2:
                added = int(parts[0]) if parts[0] != '-' else 0
                removed = int(parts[1]) if parts[1] != '-' else 0
                total_added += added
                total_removed += removed

        # Check for new files
        new_files = subprocess.run(
            ["git", "diff", "--diff-filter=A", "--name-only", base_commit],
            cwd=repo_root, capture_output=True, text=True, timeout=5
        )
        new_file_count = len(new_files.stdout.strip().split('\n')) if new_files.stdout.strip() else 0

        # Duration check
        start = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
        duration_minutes = (datetime.now(timezone.utc) - start).total_seconds() / 60

        # Apply heuristics
        if changed_files >= 4:
            return "big"
        if (total_added + total_removed) >= 200:
            return "big"
        if new_file_count >= 1:
            return "big"
        if duration_minutes >= 20:
            return "big"

        return "small"
    except:
        return "small"  # Fail safe
```

---

## SKILL.md: AUTO Markers

The top of SKILL.md is human-authored and evolves slowly. Only specific sections are machine-managed via explicit markers.

```markdown
---
schema: skill.v1
project_id: mimesis__a1b2c3d4
repo_name: mimesis
updated: 2026-01-11T09:30:00Z
---

# Mimesis

## Business Context
(Hand-maintained) What this project does, who it's for, why it exists.

## Technical Overview
(Hand-maintained) Stack, architecture, key patterns, invariants.

## Key Documentation
<!-- BEGIN:AUTO:DOCS -->
- README: README.md
- CLAUDE: CLAUDE.md
- Architecture: docs/architecture.md
<!-- END:AUTO:DOCS -->

## Current State
<!-- BEGIN:AUTO:CURRENT_STATE -->
Last big update: 2026-01-11
- Auth middleware skeleton added
- Pending OAuth config
<!-- END:AUTO:CURRENT_STATE -->

## Active Work
<!-- BEGIN:AUTO:ACTIVE_WORK -->
Status: working
Task: Implementing user authentication
Blockers: Waiting on OAuth client ID from ops
Next: Add login route tests; Update docs/auth.md
<!-- END:AUTO:ACTIVE_WORK -->
```

### Marker-Based Update Logic

```python
def update_auto_section(skill_content: str, section_name: str, new_content: str) -> str:
    """Update content between AUTO markers, preserving rest of file."""
    begin_marker = f"<!-- BEGIN:AUTO:{section_name} -->"
    end_marker = f"<!-- END:AUTO:{section_name} -->"

    pattern = re.compile(
        f"{re.escape(begin_marker)}.*?{re.escape(end_marker)}",
        re.DOTALL
    )

    replacement = f"{begin_marker}\n{new_content}\n{end_marker}"

    if pattern.search(skill_content):
        return pattern.sub(replacement, skill_content)
    else:
        # Markers missing - refuse to update (fail safe)
        return skill_content
```

---

## Notifications.jsonl

Append-only event log with deduplication support.

### Event Shape

```json
{
  "event_id": "evt_8f3a...",
  "seq": 42,
  "timestamp": "2026-01-11T09:00:05Z",
  "project_id": "mimesis__a1b2c3d4",
  "repo_name": "mimesis",
  "repo_root": "/Users/olivier/Desktop/motium_github/mimesis",
  "status": "working",
  "task_id": "2026-01-11T0900Z__auth__01",
  "task": "Implementing user authentication",
  "task_size": "big",
  "head_commit": "5d6e7f8",
  "branch": "feature/auth",
  "summary": "Started auth implementation; middleware skeleton in place"
}
```

### Event ID Generation

Deterministic for deduplication:

```python
def generate_event_id(project_id: str, updated: str, status: str, task_id: str) -> str:
    hash_input = f"{project_id}:{updated}:{status}:{task_id}"
    return f"evt_{hashlib.sha256(hash_input.encode()).hexdigest()[:12]}"
```

### File Operations

- Write events as **one line**, flush, fsync for crash safety
- Rotate daily or when > 10 MB
- Maintain cursor file for incremental reads

---

## Watcher Design

### Key Behaviors

1. **Watch glob:** `~/.claude/projects/**/.claude/status*.md`
2. **Debounce:** 250-500ms per file to avoid half-written reads
3. **Parse:** YAML front matter (gray-matter library)
4. **Dedupe:** Using `(project_id, updated, status, task_id)` or `event_id`
5. **Append:** To JSONL atomically

### Integration with Existing Daemon

Extend `packages/daemon/src/status-watcher.ts`:

```typescript
interface CommanderSink {
  onStatusChange(event: StatusEvent): void;
}

// Add to StatusWatcher constructor options
interface StatusWatcherOptions {
  debounceMs?: number;
  projectsDir?: string;
  commanderSink?: CommanderSink;  // NEW
}
```

---

## Skill Update Queue

Stop hook **never** runs a heavy process directly. It writes a request to a queue.

### Why Queue is Better

- Avoids extending Stop hook latency
- Avoids re-entrancy bugs ("hook triggers agent which triggers hook...")
- Lets you batch skill updates (coalesce multiple big tasks)

### Queue File

`~/.claude/commander/skill_update_requests.jsonl`

Stop hook appends when big:

```json
{
  "timestamp": "2026-01-11T09:30:00Z",
  "project_id": "mimesis__a1b2c3d4",
  "repo_root": "/Users/olivier/Desktop/motium_github/mimesis",
  "reason": "big_task_completed",
  "task_id": "2026-01-11T0900Z__auth__01"
}
```

### Processing

A `skill-updater` worker (module in daemon) processes requests:

1. Read request
2. Read current SKILL.md
3. Update AUTO sections only
4. Write updated SKILL.md
5. Mark request as processed (cursor update)

For POC: Deterministic updates (template-based, no LLM).
Later: LLM-based "regenerate Technical Overview" step.

---

## Commander Hook

Inject "relevant slice" not everything.

### Cursor-Based Reading

```python
def get_new_notifications(cursor_file: str, notifications_file: str) -> list:
    """Read notifications since last cursor position."""
    try:
        with open(cursor_file) as f:
            cursor = int(f.read().strip())
    except:
        cursor = 0

    notifications = []
    with open(notifications_file) as f:
        f.seek(cursor)
        for line in f:
            if line.strip():
                notifications.append(json.loads(line))
        new_cursor = f.tell()

    with open(cursor_file, 'w') as f:
        f.write(str(new_cursor))

    return notifications
```

### Fleet Summary Format

```
ğŸ“¡ Fleet Summary (last 2h)
- mimesis: working â€” Implementing user authentication (big) â€” updated 09:00Z
- project-b: completed â€” Refactor payment retries (big) â€” updated 08:40Z
- project-c: blocked â€” Waiting on API key (small) â€” updated 08:10Z
```

### Context Injection Strategy

- If user prompt references a project (by name/alias): inject last status + last N events for that project
- Otherwise: inject compact fleet summary (projects with status != idle, last big completions 24h, blockers)

---

## Project Discovery

Auto-discover projects based on status.md presence.

```python
def discover_projects() -> dict:
    """Find all projects with .claude/status.*.md files."""
    import glob
    from pathlib import Path

    projects = {}
    pattern = os.path.expanduser("~/.claude/projects/**/.claude/status*.md")

    for status_file in glob.glob(pattern, recursive=True):
        # Parse front matter to get project_id
        with open(status_file) as f:
            content = f.read()

        # Extract project_id from YAML front matter
        match = re.search(r'^project_id:\s*(\S+)', content, re.MULTILINE)
        if match:
            project_id = match.group(1)
            project_path = Path(status_file).parent.parent  # .claude/status.md -> project root

            projects[project_id] = {
                "path": str(project_path),
                "status_file": status_file,
                "has_skill": os.path.exists(
                    os.path.expanduser(f"~/.claude/skills/projects/{project_id}/SKILL.md")
                )
            }

    return projects
```

---

## File Layout

```text
~/.claude/
  commander/
    notifications.jsonl           # Cross-project event log
    notifications.cursor          # Read position for commander
    skill_update_requests.jsonl   # Queue for skill updates
    skill_update_requests.cursor  # Processing position
    state/
      projects.json               # Optional cached discovery
  skills/
    projects/
      <project_id>/
        SKILL.md                  # Per-project skill file
  hooks/
    status-working.py             # Updated for schema v2
    status-stop.py                # Updated with task_size_actual
    skill-updater.py              # Processes skill update queue
```

---

## Implementation Phases

### Phase 0: Foundation (Do First)

**Goal:** Add stable identity to status files.

1. Update `status-working.py` to write `project_id`, `repo_root`, `base_commit`, `branch`
2. Update `status-stop.py` to write `task_size_actual` computed from diff
3. Mark schema as `status.v2`

**Single biggest win:** `project_id` in front matter unlocks everything.

### Phase 1: Notification Pipeline

**Goal:** Cross-project event visibility.

1. Extend `status-watcher.ts` to watch all projects
2. Parse status files, deduplicate, append to `notifications.jsonl`
3. Implement cursor-based reading

### Phase 2: Commander Integration

**Goal:** Fleet Commander agent can answer "what's happening?"

1. Create commander skills directory structure
2. Implement SessionStart hook for fleet summary injection
3. Implement UserPromptSubmit hook for context-aware injection

### Phase 3: SKILL Updates

**Goal:** Auto-update project knowledge after big tasks.

1. Define AUTO markers in SKILL template
2. Stop hook writes to skill_update_requests.jsonl when big
3. Daemon processes queue, updates AUTO sections only

---

## Key Files to Create/Modify

### New Files

| File | Purpose |
|------|---------|
| `~/.claude/hooks/skill-updater.py` | Processes skill update queue |
| `packages/daemon/src/commander/` | Commander daemon module |
| `packages/daemon/src/commander/notifications.ts` | Write/read notifications |
| `packages/daemon/src/commander/discovery.ts` | Project discovery logic |
| `packages/daemon/src/commander/skill-patcher.ts` | AUTO section updates |

### Modified Files

| File | Changes |
|------|---------|
| `~/.claude/hooks/status-working.py` | Add project_id, repo_root, base_commit |
| `~/.claude/hooks/status-stop.py` | Add task_size_actual computation |
| `~/.claude/settings.json` | Add commander hooks |
| `packages/daemon/src/status-watcher.ts` | Watch all projects, emit to commander sink |
| `packages/daemon/src/schema.ts` | Add project_id, task_size fields |

---

## Verification Plan

1. **Status Schema v2**
   - Start worker in test project
   - Verify status file includes `project_id`, `base_commit`, `task_size_actual`

2. **Notification Pipeline**
   - Start daemon with commander module
   - Make changes in monitored project
   - Verify `notifications.jsonl` updates with correct deduplication

3. **Commander Integration**
   - Start commander agent in Mimesis
   - Ask "What's happening in project X?"
   - Verify it reads correct SKILL and status

4. **SKILL Updates**
   - Complete big task in project
   - Verify `skill_update_requests.jsonl` has entry
   - Verify SKILL.md AUTO sections updated
   - Verify hand-maintained sections unchanged

---

## Future: Bidirectional Control

When ready for "commander instructs workers", use symmetric file-based command queues:

### Commander â†’ Worker

```
~/.claude/commander/commands/<project_id>.jsonl
```

### Worker Acknowledgment

```
~/.claude/commander/command_results/<project_id>.jsonl
```

### Why File-Based

- Avoids fragile PTY control
- Works across OSes
- Simple polling from worker hook
- Auditable history

---

## Descoped (Out of Scope for v2)

- LLM-based skill regeneration (future enhancement)
- Real-time WebSocket notifications (file-based sufficient)
- Cross-project dependency detection
- Automatic task prioritization
